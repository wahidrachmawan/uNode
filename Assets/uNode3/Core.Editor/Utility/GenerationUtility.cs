using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using UnityEditor.SceneManagement;
using Object = UnityEngine.Object;

namespace MaxyGames.UNode.Editors {
	public static class GenerationUtility {
		#region Persistence Data
		[Serializable]
		public class Data {
			[SerializeField]
			public Dictionary<int, CachedScriptData> graphs = new Dictionary<int, CachedScriptData>();

			public CachedScriptData GetGraphData(UnityEngine.Object obj) {
				return GetGraphData(uNodeUtility.GetObjectID(obj));
			}

			public CachedScriptData GetGraphData(Func<CachedScriptData,bool> validation) {
				foreach(var (_, data) in graphs) {
					if(validation(data)) {
						return data;
					}
				}
				return null;
			}

			public CachedScriptData GetGraphData(int graphID) {
				if(!graphs.TryGetValue(graphID, out var scriptData)) {
					graphs[graphID] = scriptData = new CachedScriptData();
				}
				return scriptData;
			}
		}

		public class CachedScriptData {
			public string path;
			public int lastCompiledID;
			public int uniqueID;
			public float compilerVersion;
			public string[] errors;
			public string generatedScript;

			public long fileHash;
			public bool isValid => (errors == null || errors.Length == 0) && !string.IsNullOrEmpty(generatedScript) && !string.IsNullOrEmpty(path);

			public void MarkDirty() {
				path = null;
				fileHash = default;
				lastCompiledID = 0;
				compilerVersion = 0;
			}

			public void Update() {
				compilerVersion = About.compilerVersion;
			}
		}

		public static Data persistenceData => GetData();

		public static Data _data;
		public static Data GetData() {
			if(_data == null) {
				_data = uNodeEditorUtility.LoadEditorData<Data>("GeneratorData");
				if(_data == null) {
					_data = new Data();
					SaveData();
				}
			}
			return _data;
		}

		public static void SaveData() {
			if(_data != null)
				uNodeEditorUtility.SaveEditorData(_data, "GeneratorData");
		}

		public static void MarkGraphDirty(Object graphAsset) {
			if(persistenceData.graphs.TryGetValue(uNodeUtility.GetObjectID(graphAsset), out var data)) {
				data.MarkDirty();
			}
		}

		public static void MarkGraphDirty(IEnumerable<Object> graphAssets) {
			foreach(var graph in graphAssets) {
				if(graph == null)
					continue;
				MarkGraphDirty(graph);
			}
		}

		public static bool IsGraphCompiled(Object graphAsset) {
			var scriptData = persistenceData.GetGraphData(graphAsset);
			if(scriptData.isValid) {
				if(uNodePreference.preferenceData.generatorData.compilationMethod == CompilationMethod.Roslyn) {
					return File.Exists(tempAssemblyPath) && File.Exists(scriptData.path);
				} else {
					return true;
				}
			}
			return false;
		}

		public static bool IsGraphUpToDate(Object graphAsset) {
			var scriptData = persistenceData.GetGraphData(graphAsset);
			if(scriptData.compilerVersion != About.compilerVersion)
				return false;
			if(scriptData.isValid && File.Exists(scriptData.path)) {
				var hash = uNodeUtility.GetFileHashCached(AssetDatabase.GetAssetPath(graphAsset));
				return scriptData.fileHash == hash;
			}
			return false;
		}
		#endregion

		static uNodePreference.PreferenceData _preferenceData;
		private static uNodePreference.PreferenceData preferenceData {
			get {
				if(_preferenceData != uNodePreference.GetPreference()) {
					_preferenceData = uNodePreference.GetPreference();
				}
				return _preferenceData;
			}
		}
		/// <summary>
		/// Represents the name of the temporary folder used for storing scripts.
		/// </summary>
		/// <remarks>This constant defines the folder name "TempScript" and can be used to reference the temporary
		/// script storage location in the application.</remarks>
		public const string tempFolder = "TempScript";
		/// <summary>
		/// Represents the path to the temporary folder used for storing generated scripts.
		/// </summary>
		public static string tempGeneratedFolder => tempFolder + Path.DirectorySeparatorChar + "Generated";
		/// <summary>
		/// Represents the path to the temporary Roslyn folder used for storing generated scripts.
		/// </summary>
		public static string tempRoslynFolder => tempFolder + Path.DirectorySeparatorChar + "Scripts";
		/// <summary>
		/// Represents the path to the temporary assembly file generated by Roslyn.
		/// </summary>
		public static string tempAssemblyPath => tempRoslynFolder + Path.DirectorySeparatorChar + "RuntimeAssembly.dll";
		/// <summary>
		/// Represents the path to the temporary assembly file generated by Roslyn for editor scripts.
		/// </summary>
		public static string generatedPath => "Assets" + Path.DirectorySeparatorChar + "uNode.Generated";
		/// <summary>
		/// Represents the path to the resources folder where generated resources are stored.
		/// </summary>
		public static string resourcesPath => generatedPath + Path.DirectorySeparatorChar + "Resources";
		/// <summary>
		/// Represents the path to the project script folder where generated scripts are stored.
		/// </summary>
		public static string projectScriptPath => generatedPath + Path.DirectorySeparatorChar + "Scripts";
		/// <summary>
		/// Represents the path to the project scene script folder where generated scene scripts are stored.
		/// </summary>
		public static string projectSceneScriptPath => projectScriptPath + Path.DirectorySeparatorChar + "Scene";
		/// <summary>
		/// Represents the path to the project prefab script folder where generated prefab scripts are stored.
		/// </summary>
		public static string projectPrefabScriptPath => projectScriptPath + Path.DirectorySeparatorChar + "Prefab";

		/// <summary>
		/// Gets the uNode database, creating a new one if it does not exist.
		/// </summary>
		/// <returns></returns>
		public static uNodeDatabase GetDatabase() {
			var db = uNodeUtility.GetDatabase();
			if(db == null) {
				db = ScriptableObject.CreateInstance<uNodeDatabase>();
				var dbDir = resourcesPath;
				Directory.CreateDirectory(dbDir);
				var path = dbDir + Path.DirectorySeparatorChar + "uNodeDatabase.asset";
				Debug.Log($"No database found, creating new database in: {path}");
				AssetDatabase.CreateAsset(db, path);
			}
			return db;
		}

		/// <summary>
		/// Generates full C# scripts for all project graphs ( skip all graph that has up to date generated script ).
		/// </summary>
		/// <remarks>This method determines the appropriate compilation method based on the user's preferences and 
		/// generates the necessary C# scripts for the project. If the Roslyn compilation method is selected  and pre-existing
		/// generated scripts are found in the project folder, a warning is logged to inform  the user to delete them to avoid
		/// conflicts. For users with the Pro version of uNode, background  compilation is supported if enabled in the
		/// preferences.</remarks>
		[MenuItem("Tools/uNode/Generate C# Scripts", false, 22)]
		public static void GenerateCSharpScript() {
			if(preferenceData.generatorData.compilationMethod == CompilationMethod.Unity) {
				CompileProjectGraphs(false);
			} else {
				if(IsCompiledScriptExistInProject(true, false, false)) {
					Debug.LogWarning($"Warning: You're using Roslyn Compilation method but there's a generated script located on: {projectScriptPath} folder, please delete it to ensure script is working.\nIf the generated script in {projectScriptPath} folder still exist the graph will run with that script.");
				}
				if(preferenceData.generatorData.compileInBackground && uNodeUtility.IsProVersion) {
					CompileGraphsInBackground(false);
				} else {
					CompileProjectGraphs(true, false);
				}
			}
		}

		/// <summary>
		/// Generates full C# scripts for all project graphs.
		/// </summary>
		/// <remarks>This method determines the appropriate compilation method (Unity or Roslyn) and generates the
		/// necessary C# scripts for the project graphs. If the Roslyn compilation method is used and pre-existing compiled
		/// scripts are detected in the project folder, a warning is logged to notify the user to delete them to avoid
		/// conflicts. For users with the Pro version,  background compilation is supported if enabled in the
		/// preferences.</remarks>
		[MenuItem("Tools/uNode/Advanced/Generate C# Scripts ( Full )", false, 1000010)]
		public static void GenerateCSharpScriptFull() {
			if(preferenceData.generatorData.compilationMethod == CompilationMethod.Unity) {
				CompileProjectGraphs(true);
			}
			else {
				if(IsCompiledScriptExistInProject(true, false, false)) {
					Debug.LogWarning($"Warning: You're using Roslyn Compilation method but there's a generated script located on: {projectScriptPath} folder, please delete it to ensure script is working.\nIf the generated script in {projectScriptPath} folder still exist the graph will run with that script.");
				}
				if(preferenceData.generatorData.compileInBackground && uNodeUtility.IsProVersion) {
					CompileGraphsInBackground(true);
				}
				else {
					CompileProjectGraphs(true, true);
				}
			}
		}

		/// <summary>
		/// Compiles project graphs into C# scripts and optionally saves them in a temporary folder or the project script
		/// directory.
		/// </summary>
		/// <remarks>This method generates C# scripts for project graphs and handles their saving and compilation.  If
		/// <paramref name="saveInTemporaryFolder"/> is <see langword="true"/>, the scripts are compiled into a temporary
		/// assembly.  Otherwise, the scripts are saved in the project script directory, and the Unity asset database is
		/// refreshed. <para> Generated scripts allow project graphs to run with native C# instead of reflection.  If changes
		/// are made to the graphs, this method should be called again to ensure the scripts are up to date. </para> <para>
		/// Note: Removing the generated scripts will cause the graphs to revert to running with reflection. </para></remarks>
		/// <param name="saveInTemporaryFolder">A boolean value indicating whether the generated scripts should be saved in a temporary folder.  If <see
		/// langword="true"/>, the scripts are saved in a temporary directory; otherwise, they are saved in the project script
		/// directory.</param>
		/// <param name="force">A boolean value indicating whether to force the regeneration of project scripts.  If <see langword="true"/>, all
		/// scripts are regenerated regardless of their current state.</param>
		public static void CompileProjectGraphs(bool saveInTemporaryFolder = false, bool force = true) {
			try {
				var scripts = GenerationUtility.GenerateProjectScripts(force);
				var db = GetDatabase();
				EditorUtility.DisplayProgressBar("Saving Scripts", "", 1);
				string dir;
				List<string> scriptPaths = null;
				if(saveInTemporaryFolder) {
					dir = tempRoslynFolder;
					scriptPaths = new List<string>();
				} else {
					dir = projectScriptPath;
				}
				Directory.CreateDirectory(dir);
				foreach(var script in scripts) {
					string path;
					if(string.IsNullOrWhiteSpace(script.Namespace) == false) {
						Directory.CreateDirectory(dir + Path.DirectorySeparatorChar + script.Namespace);
						path = Path.GetFullPath(dir) + Path.DirectorySeparatorChar + script.Namespace + Path.DirectorySeparatorChar + script.fileName + ".cs";
					}
					else {
						path = Path.GetFullPath(dir) + Path.DirectorySeparatorChar + script.fileName + ".cs";
					}
					var assetPath = AssetDatabase.GetAssetPath(script.graphOwner);
					if(File.Exists(assetPath.RemoveLast(6).Add("cs"))) {
						//Skip when the graph has been compiled manually
						continue;
					}
					if(saveInTemporaryFolder)
						scriptPaths.Add(path);
					List<ScriptInformation> informations;
					var generatedScript = script.ToScript(out informations, true);
					using(StreamWriter sw = new StreamWriter(path)) {
						if(informations != null) {
							uNodeEditor.SavedData.RegisterGraphInfos(informations, script.graphOwner, path);
						}
						sw.Write(ConvertLineEnding(generatedScript, Application.platform != RuntimePlatform.WindowsEditor));
						sw.Close();
					}
					if(EditorUtility.IsPersistent(script.graphOwner)) {
						var scriptData = persistenceData.GetGraphData(script.graphOwner);
						scriptData.path = path;
						scriptData.fileHash = uNodeUtility.GetFileHash(AssetDatabase.GetAssetPath(script.graphOwner));
						scriptData.lastCompiledID = script.GetSettingUID();
						scriptData.generatedScript = generatedScript;
						scriptData.Update();

					}
					GraphUtility.UpdateDatabase(new[] { script });
				}
				if(saveInTemporaryFolder) {
					EditorUtility.DisplayProgressBar("Compiling Scripts", "", 1);
					var result = RoslynUtility.CompileFilesAndSave(Path.GetRandomFileName(), scriptPaths, tempAssemblyPath, false);
					if(result.errors != null && result.errors.Any()) {
						Debug.LogError(result.GetErrorMessage());
					}
				} else {
					AssetDatabase.SaveAssets();
					if(uNodePreference.preferenceData.IsAutoRefreshEnabled) {
						AssetDatabase.Refresh();
					}
				}
				uNodeDatabase.ClearCache();
				Debug.Log("Successful generating project script, project graphs will run with native c#." +
				"\nRemember to compiles the graph again if you made a changes to a graphs to keep the script up to date." +
				"\nRemoving generated scripts will makes the graph to run with reflection again." +
				"\nGenerated project script can be found on: " + dir);
			}
			finally {
				EditorUtility.ClearProgressBar();
			}
		}

		private static bool IsCompiledScriptExistInProject(bool checkProjectGraph, bool checkSceneGraph, bool checkPrefabGraph) {
			if(checkProjectGraph && checkSceneGraph && checkPrefabGraph) {
				if(Directory.Exists(projectScriptPath)) {
					return true;
				}
			}
			if(checkPrefabGraph) {
				if(Directory.Exists(projectScriptPath) && Directory.EnumerateFiles(projectScriptPath).Any(name => name.EndsWith(".cs"))) {
					return true;
				}
			}
			if(checkSceneGraph) {
				if(Directory.Exists(projectSceneScriptPath) && Directory.EnumerateFiles(projectSceneScriptPath).Any(name => name.EndsWith(".cs"))) {
					return true;
				}
			}
			if(checkPrefabGraph) {
				if(Directory.Exists(projectPrefabScriptPath) && Directory.EnumerateFiles(projectPrefabScriptPath).Any(name => name.EndsWith(".cs"))) {
					return true;
				}
			}
			return false;
		}

		/// <summary>
		/// Generates C# scripts for all graphs, including those in scenes, prefabs, and the project.
		/// </summary>
		/// <remarks>This method saves any modified scenes before proceeding. It generates scripts for graphs based on
		/// the  selected compilation method in the preferences. If the Roslyn compilation method is used and a previously 
		/// generated script exists in the project folder, a warning is logged to inform the user to delete the script  to
		/// ensure proper functionality. Scripts for prefab and scene graphs are also generated as part of this
		/// process.</remarks>
		[MenuItem("Tools/uNode/Generate C# including Scenes", false, 23)]
		public static void GenerateCSharpScriptIncludingSceneGraphs() {
			if(!EditorSceneManager.SaveCurrentModifiedScenesIfUserWantsTo()) {
				return;
			}
			if(preferenceData.generatorData.compilationMethod == CompilationMethod.Unity) {
				CompileProjectGraphs();
			} else {
				if(IsCompiledScriptExistInProject(true, false, false)) {
					Debug.LogWarning($"Warning: You're using Roslyn Compilation method but there's a generated script located on: {projectScriptPath} folder, please delete it to ensure script is working.\nIf the generated script in {projectScriptPath} folder still exist the graph will run with that script.");
				}
				CompileProjectGraphs(true, false);
			}
			GenerateCSharpScriptForPrefabGraphs();
			GenerateCSharpScriptForSceneGraphs();
		}

		/// <summary>
		/// Generates C# scripts for all scene graphs in the project.
		/// </summary>
		/// <remarks>This method processes all enabled scenes in the project's build settings, generates C# scripts
		/// for graph components within those scenes, and saves the scripts to a designated directory. Existing generated
		/// scripts are deleted before new ones are created to ensure no outdated scripts remain.  The generated scripts allow
		/// scene graphs to run natively in C#, improving performance. If the generated scripts are removed, the graphs will
		/// revert to running with reflection. Developers should recompile the graphs if changes are made to ensure the
		/// scripts remain up-to-date.  The generated scripts are saved in the directory specified by
		/// <c>projectSceneScriptPath</c>.</remarks>
		public static void GenerateCSharpScriptForSceneGraphs() {
			try {
				DeleteGeneratedCSharpScriptForScenes();//Removing previous files so there's no outdated scripts
				var scenes = EditorBuildSettings.scenes;
				var dir = projectSceneScriptPath;
				// uNodeEditorUtility.FindAssetsByType<SceneAsset>();
				for(int i = 0; i < scenes.Length; i++) {
					var scene = scenes[i];
					var sceneAsset = AssetDatabase.LoadAssetAtPath<SceneAsset>(scene.path);
					if(sceneAsset == null || !scene.enabled) continue;
					EditorUtility.DisplayProgressBar($"Loading Scene: {sceneAsset.name} {i + 1}-{scenes.Length}", "", 0);
					GenerateCSharpScriptForSceneGraphs(sceneAsset, (progress, info, current, count) => {
						EditorUtility.DisplayProgressBar($"Generating C# for: {sceneAsset.name} {i + 1}-{scenes.Length} current: {current}-{count}", info, progress);
					});
				}
				AssetDatabase.SaveAssets();
				if(uNodePreference.preferenceData.IsAutoRefreshEnabled) {
					AssetDatabase.Refresh();
				}
				Debug.Log("Successful generating scenes script, existing scenes graphs will run with native c#." +
					"\nRemember to compiles the graph again if you made a changes to a graphs to keep the script up to date." +
					"\nRemoving generated scripts will makes the graph to run with reflection again." +
					"\nGenerated scenes script can be found on: " + dir);
			}
			finally {
				EditorUtility.ClearProgressBar();
			}
		}

		/// <summary>
		/// Generates C# scripts for all scene graphs in the specified scene asset.
		/// </summary>
		/// <remarks>This method processes all graph components in the specified scene, generates corresponding C#
		/// scripts, and saves them to a predefined directory. The generated script filenames are made unique to avoid
		/// overwriting existing files. The method also ensures that any required updates to the threading utility are
		/// performed during the process.</remarks>
		/// <param name="sceneAsset">The scene asset containing the graphs for which scripts will be generated. Cannot be null.</param>
		/// <param name="updateProgress">An optional callback to report progress during script generation. The callback provides the following parameters:
		/// <list type="bullet"> <item><description><paramref name="progress"/>: A value between 0 and 1 indicating the
		/// progress of the current graph's script generation.</description></item> <item><description><paramref
		/// name="info"/>: A string containing information about the current operation.</description></item>
		/// <item><description><paramref name="current"/>: The index of the current graph being processed
		/// (1-based).</description></item> <item><description><paramref name="graphs.Length"/>: The total number of graphs to
		/// process.</description></item> </list></param>
		public static void GenerateCSharpScriptForSceneGraphs(SceneAsset sceneAsset, Action<float, string, int, int> updateProgress = null) {
			while(uNodeThreadUtility.IsNeedUpdate()) {
				uNodeThreadUtility.Update();
			}
			var currentScene = EditorSceneManager.OpenScene(AssetDatabase.GetAssetPath(sceneAsset));
#pragma warning disable
			var graphs = GameObject.FindObjectsOfType<GraphComponent>();
#pragma warning restore
			var scripts = new List<CG.GeneratedData>();
			int current = 0;
			foreach(var graph in graphs) {
				if(uNodeEditorUtility.IsPrefabInstance(graph))
					continue;
				current++;
				scripts.Add(GenerationUtility.GenerateCSharpScript(graph, (progress, info) => {
					updateProgress?.Invoke(progress, info, current, graphs.Length);
				}));
			}
			while(uNodeThreadUtility.IsNeedUpdate()) {
				uNodeThreadUtility.Update();
			}
			EditorSceneManager.SaveScene(currentScene);
			EditorUtility.DisplayProgressBar("Saving Scene Scripts", "", 1);
			Directory.CreateDirectory(projectSceneScriptPath);
			var startPath = Path.GetFullPath(projectSceneScriptPath) + Path.DirectorySeparatorChar;
			foreach(var script in scripts) {
				var path = startPath + currentScene.name + "_" + script.fileName + ".cs";
				int index = 1;
				while(File.Exists(path)) {//Ensure name to be unique
					path = startPath + currentScene.name + "_" + script.fileName + index + ".cs";
					index++;
				}
				using(StreamWriter sw = new StreamWriter(path)) {
					List<ScriptInformation> informations;
					var generatedScript = script.ToScript(out informations, true);
					if(informations != null) {
						uNodeEditor.SavedData.RegisterGraphInfos(informations, script.graphOwner, path);
					}
					sw.Write(GenerationUtility.ConvertLineEnding(generatedScript, false));
					sw.Close();
				}
			}
		}

		/// <summary>
		/// Generates C# scripts for all prefab graphs containing <see cref="GraphComponent"/> instances.
		/// </summary>
		/// <remarks>This method scans all prefabs in the project for components of type <see cref="GraphComponent"/>,
		/// generates corresponding C# scripts for their graphs, and saves the scripts to a predefined directory.  Existing
		/// generated scripts are deleted before new ones are created to ensure no outdated scripts remain. <para> The
		/// generated scripts allow prefab graphs to run natively in C# instead of using reflection,  improving performance.
		/// If the generated scripts are removed, the graphs will revert to running with reflection. </para> <para> The
		/// generated scripts are saved in the directory specified by <c>projectPrefabScriptPath</c>.  Ensure to recompile the
		/// graphs if any changes are made to keep the scripts up to date. </para></remarks>
		[MenuItem("Tools/uNode/Advanced/Generate C# for Prefabs", false, 1000011)]
		public static void GenerateCSharpScriptForPrefabGraphs() {
			try {
				DeleteGeneratedCSharpScriptForPrefab();//Removing previous files so there's no outdated scripts
				var prefabs = uNodeEditorUtility.FindPrefabsOfType<GraphComponent>();
				var dir = projectPrefabScriptPath;
				int compiledCount = 0;
				for(int i = 0; i < prefabs.Count; i++) {
					var prefab = prefabs[i];
					var graphs = prefab.GetComponentsInChildren<GraphComponent>();
					var scripts = new List<CG.GeneratedData>();
					int count = 0;
					foreach(var graph in graphs) {
						count++;
						scripts.Add(GenerateCSharpScript(graph, (progress, info) => {
							EditorUtility.DisplayProgressBar($"Generating C# for prefab: {prefab.name} {i + 1}-{graphs.Length} current: {count}-{graphs.Length}", info, progress);
						}));
						compiledCount++;
					}
					while(uNodeThreadUtility.IsNeedUpdate()) {
						uNodeThreadUtility.Update();
					}
					uNodeEditorUtility.MarkDirty(prefab);
					Directory.CreateDirectory(dir);
					var startPath = Path.GetFullPath(dir) + Path.DirectorySeparatorChar;
					foreach(var script in scripts) {
						string fileName = script.fileName;
						if(script.classNames.Count > 0) {
							var nm = script.classNames.FirstOrDefault(pair => !string.IsNullOrEmpty(pair.Value)).Value;
							if(!string.IsNullOrEmpty(nm)) {
								fileName = nm;
							}
						}

						var path = startPath + fileName + ".cs";
						int index = 1;
						while(File.Exists(path)) {//Ensure name to be unique
							path = startPath + fileName + index + ".cs";
							index++;
						}
						using(StreamWriter sw = new StreamWriter(path)) {
							List<ScriptInformation> informations;
							var generatedScript = script.ToScript(out informations, true);
							if(informations != null) {
								uNodeEditor.SavedData.RegisterGraphInfos(informations, script.graphOwner, path);
							}
							sw.Write(GenerationUtility.ConvertLineEnding(generatedScript, false));
							sw.Close();
						}
					}
				}
				if(compiledCount > 0) {
					AssetDatabase.SaveAssets();
					if(uNodePreference.preferenceData.IsAutoRefreshEnabled) {
						AssetDatabase.Refresh();
					}
					Debug.Log("Successful generating prefab script, existing prefab graphs will run with native c#." +
						"\nCompiled graph count: " + compiledCount +
						"\nRemember to compiles the graph again if you made a changes to a graphs to keep the script up to date." +
						"\nRemoving generated scripts will makes the graph to run with reflection again." +
						"\nGenerated scenes script can be found on: " + dir);
				}
				else {
					Debug.Log("There's no prefab with GraphComponent exists");
				}
			}
			finally {
				EditorUtility.ClearProgressBar();
			}
		}


		private static bool isGeneratingInBackground;
		/// <summary>
		/// Compile project runtime graphs in the background.
		/// </summary>
		public static void CompileGraphsInBackground(bool force) {
			if(!isGeneratingInBackground) {
				isGeneratingInBackground = true;
				uNodeThreadUtility.CreateThread(() => DoCompileGraphsInBackground(force)).Start();
			}
		}

		/// <summary>
		/// Generate and compile all runtime graphs in background.
		/// Note: don't call it from main thread.
		/// </summary>
		public static void DoCompileGraphsInBackground(bool force = false) {
			try {
#if !UNODE_PRO
				if(uNodeUtility.IsProVersion == false) {
					throw new Exception("Compile in background is pro only feature");
				}
#endif
				uNodeThreadUtility.WaitOneFrame();
				var dir = tempRoslynFolder;
				var dirInfo = Directory.CreateDirectory(dir);
				var scripts = GenerationUtility.GenerateRuntimeGraphAsync(force);
				var scriptPaths = new List<string>();
				int skippedCount = 0;
				uNodeThreadUtility.QueueAndWait(() => {
					var db = GetDatabase();
					EditorProgressBar.ShowProgressBar("Saving Scripts", 1);
					foreach(var script in scripts) {
						if(script == null)
							continue;
						string path;
						if(string.IsNullOrWhiteSpace(script.Namespace) == false) {
							Directory.CreateDirectory(dir + Path.DirectorySeparatorChar + script.Namespace);
							path = Path.GetFullPath(dir) + Path.DirectorySeparatorChar + script.Namespace + Path.DirectorySeparatorChar + script.fileName + ".cs";
						}
						else {
							path = Path.GetFullPath(dir) + Path.DirectorySeparatorChar + script.fileName + ".cs";
						}
						//var assetPath = AssetDatabase.GetAssetPath(script.graphOwner);
						//if(File.Exists(assetPath.RemoveLast(6).Add("cs"))) {
						//	//Skip when the graph has been compiled manually
						//	continue;
						//}
						if(!script.isValid) {
							if(File.Exists(path)) {
								scriptPaths.Add(path);
								skippedCount++;
							}
							if(script.hasError) {
								string errors = null;
								foreach(var e in script.errors) {
									errors += e.ToString() + "\n";
								}
								Debug.LogError("Generating script in background has an errors, errors: \n" + errors);
							}
							continue;
						}
						List<ScriptInformation> informations;
						var generatedScript = script.ToScript(out informations, true);
						using(StreamWriter sw = new StreamWriter(path)) {
							if(informations != null) {
								uNodeEditor.SavedData.RegisterGraphInfos(informations, script.graphOwner, path);
							}
							sw.Write(ConvertLineEnding(generatedScript, Application.platform != RuntimePlatform.WindowsEditor));
							sw.Close();
						}
						scriptPaths.Add(path);
						if(EditorUtility.IsPersistent(script.graphOwner)) {
							var scriptData = persistenceData.GetGraphData(script.graphOwner);
							scriptData.path = path;
							scriptData.fileHash = uNodeUtility.GetFileHash(AssetDatabase.GetAssetPath(script.graphOwner));
							var lastCompiledID = script.GetSettingUID();
							if(scriptData.generatedScript != generatedScript || scriptData.lastCompiledID != lastCompiledID || scriptData.compilerVersion != About.compilerVersion) {
								scriptData.generatedScript = generatedScript;
								scriptData.lastCompiledID = lastCompiledID;
								scriptData.Update();
							} else {
								skippedCount++;
							}
						}
						GraphUtility.UpdateDatabase(new[] { script });
					}
					uNodeDatabase.ClearCache();
					//foreach(var file in dirInfo.EnumerateFiles()) {
					//	if(file.Extension == ".cs") {
					//		scriptPaths.Add(Path.GetFullPath(dir) + Path.DirectorySeparatorChar + file.Name);
					//	}
					//}
				});
				if(scriptPaths.Count != skippedCount || !File.Exists(tempAssemblyPath)) {
					uNodeThreadUtility.QueueAndWait(() => {
						EditorProgressBar.ShowProgressBar("Compiling Scripts", 1);
					});
					var result = RoslynUtility.CompileFilesAndSave(Path.GetRandomFileName(), scriptPaths, tempAssemblyPath, false);
					if(result == null) {
						throw new Exception("Something wrong with compile using Roslyn.");
					}
					if(result.errors != null && result.errors.Any()) {
						string additionalInfo = null;
						var map = persistenceData.graphs.ToList();
						foreach(var error in result.errors) {
							if(!string.IsNullOrEmpty(error.fileName)) {
								foreach(var pair in map) {
									if(pair.Value.path == error.fileName && !error.isWarning) {
										//Make sure to reset the hash for graph that has error message.
										pair.Value.fileHash = default;
										pair.Value.generatedScript = string.Empty;

										additionalInfo += "\n" + GraphException.GetMessage("", pair.Key, 0, null);
									}
								}
							}
							//uNodeDebug.LogError(error.errorMessage);
						}
						Debug.LogError(result.GetErrorMessage() + additionalInfo);
						//Debug.LogError($"Error compiling graphs. {uNodeLogger.uNodeConsoleWindow.KEY_OpenConsole}\n" + result.GetErrorMessage());
					} else {
						Debug.Log("Successful generating and compiling project script, project graphs will run with native c#." +
						"\nRemember to compiles the graph again if you made a changes to a graphs to keep the script up to date." +
						"\nRemoving generated scripts will makes the graph to run with reflection again." +
						"\nGenerated project script can be found on: " + dir);
					}
				}
				else if(scriptPaths.Count == skippedCount) {
					Debug.Log("Successful generating but skipping compiling because all script are up to date");
				}
			}
			finally {
				isGeneratingInBackground = false;
				uNodeThreadUtility.Queue(() => {
					EditorProgressBar.ClearProgressBar();
				});
			}
		}

#region Delete Generated Script
		[MenuItem("Tools/uNode/Delete Generated C# Scripts", false, 30)]
		public static void DeleteGeneratedCSharpScript() {
			EditorUtility.DisplayProgressBar("Deleting Generated C# Scripts", "", 1);
			if(Directory.Exists(projectScriptPath)) {
				Directory.Delete(projectScriptPath, true);
			}
			if(File.Exists(projectScriptPath + ".meta")) {
				File.Delete(projectScriptPath + ".meta");
			}
			if(File.Exists(tempAssemblyPath)) {
				File.Delete(tempAssemblyPath);
			}
			//For marking all graph to dirty to it will always get compiled in future
			if(persistenceData != null && persistenceData.graphs != null) {
				foreach(var data in persistenceData.graphs) {
					data.Value?.MarkDirty();
				}
			}
			AssetDatabase.Refresh();
			EditorUtility.ClearProgressBar();
		}

		public static void DeleteGeneratedCSharpScriptForScenes() {
			EditorUtility.DisplayProgressBar("Deleting Generated C# Scripts", "", 1);
			var dir = projectSceneScriptPath;
			if(Directory.Exists(dir)) {
				Directory.Delete(dir, true);
			}
			if(File.Exists(dir + ".meta")) {
				File.Delete(dir + ".meta");
			}
			AssetDatabase.Refresh();
			EditorUtility.ClearProgressBar();
		}

		public static void DeleteGeneratedCSharpScriptForPrefab() {
			EditorUtility.DisplayProgressBar("Deleting Generated C# Scripts for prefab", "", 1);
			var dir = projectPrefabScriptPath;
			if(Directory.Exists(dir)) {
				Directory.Delete(dir, true);
			}
			if(File.Exists(dir + ".meta")) {
				File.Delete(dir + ".meta");
			}
			AssetDatabase.Refresh();
			EditorUtility.ClearProgressBar();
		}
		#endregion

		public static void GenerateNativeGraphsInProject(bool enableLogging = true) {
			GenerateNativeGraphs(GraphUtility.FindAllGraphAssets().Where(obj => obj is IScriptGraph).Select(g => g as IScriptGraph), enableLogging);
		}

		public static void GenerateNativeGraphs(IEnumerable<IScriptGraph> graphs, bool enableLogging = true) {
			try {
				System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch();
				watch.Start();
				var scripts = GenerateNativeProjectScripts(graphs, true);
				watch.Stop();
				if(enableLogging)
					Debug.LogFormat("Generating C# took {0,8:N3} s.", watch.Elapsed.TotalSeconds);
				var dir = "TempScript" + Path.DirectorySeparatorChar + "GeneratedCSharpGraph";
				Directory.CreateDirectory(dir);
				HashSet<string> fileNames = new HashSet<string>();
				List<string> paths = new List<string>();
				Action saveAction = null;
				foreach(var script in scripts) {
					var fileName = script.fileName;
					int index = 2;
					while(!fileNames.Add(fileName)) {
						fileName = script.fileName + index;
					}
					if(preferenceData.generatorData.compileBeforeSave) {//Save to temp
						string path;
						if(string.IsNullOrWhiteSpace(script.Namespace) == false) {
							Directory.CreateDirectory(dir + Path.DirectorySeparatorChar + script.Namespace);
							path = Path.GetFullPath(dir) + Path.DirectorySeparatorChar + script.Namespace + Path.DirectorySeparatorChar + fileName + ".cs";
						}
						else {
							path = Path.GetFullPath(dir) + Path.DirectorySeparatorChar + fileName + ".cs";
						}
						using(StreamWriter sw = new StreamWriter(path)) {
							var generatedScript = script.ToScript(out var informations, true);
							if(informations != null) {
								uNodeEditor.SavedData.RegisterGraphInfos(informations, script.graphOwner, path);
							}
							sw.Write(preferenceData.generatorData.convertLineEnding ? ConvertLineEnding(generatedScript, Application.platform != RuntimePlatform.WindowsEditor) : generatedScript);
							sw.Close();
						}
						paths.Add(path);
					}
					{//Save to project
						saveAction += () => {
							var path = (Path.GetDirectoryName(AssetDatabase.GetAssetPath(script.graphOwner)) + Path.DirectorySeparatorChar + script.graphOwner.name + ".cs");
							using(StreamWriter sw = new StreamWriter(path)) {
								var generatedScript = script.ToScript(out var informations, true);
								if(informations != null) {
									uNodeEditor.SavedData.RegisterGraphInfos(informations, script.graphOwner, path);
								}
								sw.Write(preferenceData.generatorData.convertLineEnding ? ConvertLineEnding(generatedScript, Application.platform != RuntimePlatform.WindowsEditor) : generatedScript);
								sw.Close();
							}
						};
					}
				}
				if(preferenceData.generatorData.compileBeforeSave) {
					watch.Restart();
					EditorUtility.DisplayProgressBar("Loading", "Compiling", 1);
					CompileFromFile(paths.ToArray());
					watch.Stop();
					if(enableLogging)
						Debug.LogFormat("Compiling script took {0,8:N3} s.", watch.Elapsed.TotalSeconds);
				}
				saveAction?.Invoke();
				if(uNodePreference.preferenceData.IsAutoRefreshEnabled) {
					AssetDatabase.Refresh();
				}
				AssetDatabase.SaveAssets();
				Debug.Log("Successful generating script for C# Graphs in the project.");
			}
			finally {
				uNodeThreadUtility.QueueOnFrame(() => {
					EditorUtility.ClearProgressBar();
				});
			}
		}

		private static CG.GeneratedData[] GenerateNativeProjectScripts(
			IEnumerable<IScriptGraph> graphs,
			bool force = true,
			string label = "Generating C# Scripts",
			bool clearProgressOnFinish = true) {
			try {
				int count = 0;
				var objects = graphs.Select(g => g as Object).ToArray();
				var scripts = objects.Select(gameObject => {
					count++;
					return GenerateCSharpScript(gameObject, (progress, text) => {
						EditorUtility.DisplayProgressBar($"{label} {count}-{objects.Length}", text, progress);
					});
				}).Where(s => s != null);
				return scripts.ToArray();
			}
			finally {
				if(clearProgressOnFinish) {
					uNodeThreadUtility.QueueOnFrame(() => {
						EditorUtility.ClearProgressBar();
					});
				}
			}
		}

		public static void CompileNativeGraphInProject() {
			CompileNativeGraph(GraphUtility.FindAllGraphAssets().Where(obj => obj is IScriptGraph));
		}

		public static void CompileNativeGraph(IEnumerable<Object> graphs) {
			foreach(var graph in graphs) {
				CompileNativeGraph(graph);
			}
		}

		public static void CompileNativeGraph(Object graphObject, bool enableLogging = true) {
			if(EditorUtility.IsPersistent(graphObject)) {
				if(AssetDatabase.IsSubAsset(graphObject)) {
					if(graphObject is IScriptGraphType scriptGraphType && scriptGraphType.ScriptTypeData.scriptGraphReference != null) {
						graphObject = scriptGraphType.ScriptTypeData.scriptGraphReference;
					} else {
						if(graphObject == null) return;
						throw new Exception("Attemp to compile sub asset which is not supported.\nType:" + graphObject.GetType());
					}
				}
			}
			string fileName = graphObject.name;
			GameObject prefabContent = null;
			var objectToCompile = graphObject;
			if(uNodeEditorUtility.IsPrefab(graphObject)) {
				prefabContent = PrefabUtility.LoadPrefabContents(AssetDatabase.GetAssetPath(graphObject));
				objectToCompile = prefabContent;
			}
			Directory.CreateDirectory(GenerationUtility.tempFolder);
			char separator = Path.DirectorySeparatorChar;
			string path = GenerationUtility.tempFolder + separator + fileName + ".cs";
			try {
				System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch();
				watch.Start();
				var script = GenerationUtility.GenerateCSharpScript(objectToCompile, (progress, text) => {
                    EditorUtility.DisplayProgressBar("Loading", text, progress);
                });
				if(preferenceData.generatorData.convertLineEnding) {
					script.postScriptModifier += input => {
						return GenerationUtility.ConvertLineEnding(input, Application.platform != RuntimePlatform.WindowsEditor);
					};
				}
				if(preferenceData.generatorData != null && preferenceData.generatorData.analyzeScript && preferenceData.generatorData.formatScript) {
					script.postScriptModifier += EditorBinding.AnalizeCode;
				}

				List<ScriptInformation> informations;
				var generatedScript = script.ToScript(out informations, true);
				using(StreamWriter sw = new StreamWriter(path)) {
					sw.Write(generatedScript);
					sw.Close();
				}
				watch.Stop();
				if(enableLogging)
					Debug.LogFormat("Generating C# took {0,8:N3} s.", watch.Elapsed.TotalSeconds);
				if(preferenceData.generatorData.compileBeforeSave && uNodeUtility.IsProVersion) {
					bool isBecauseOfAccessibility = false;
					try {
						watch.Reset();
						EditorUtility.DisplayProgressBar("Loading", "Compiling", 1);
						watch.Start();
						var compileResult = CompileScript(generatedScript);
						watch.Stop();
#if !NET_STANDARD_2_0
						if(enableLogging)
							Debug.LogFormat("Compiling script took {0,8:N3} s.", watch.Elapsed.TotalSeconds);
#endif

						if(compileResult.isSuccess == false) {
							isBecauseOfAccessibility = true;
							foreach(var error in compileResult.errors) {
								if(error.errorNumber != "CS0122") {
									isBecauseOfAccessibility = false;
									break;
								}
							}
							throw new Exception(compileResult.GetErrorMessage());
						}
					}
					catch (System.Exception ex) {
						watch.Stop();
						EditorUtility.ClearProgressBar();
						if(EditorUtility.DisplayDialog("Compile Errors", "Compile before save detect an error: \n" + ex.Message + "\n\n" +
							(isBecauseOfAccessibility ?
								"The initial errors may because of using a private class.\nWould you like to ignore the error and save it?" : 
								"Would you like to ignore the error and save it?"),
							"Ok, save it",
							"No, don't save")) {
							Debug.Log("Compile errors: " + ex.Message);
						} else {
							Debug.Log("Temp script saved to: " + Path.GetFullPath(path));
							throw ex;
						}
					}
				}
				if(EditorUtility.IsPersistent(graphObject)) {//For prefab and asset
					path = (Path.GetDirectoryName(AssetDatabase.GetAssetPath(graphObject)) + separator + fileName + ".cs");
					if(informations != null) {
						uNodeEditor.SavedData.RegisterGraphInfos(informations, script.graphOwner, path);
					}
					using(FileStream stream = File.Open(path, FileMode.Create, FileAccess.Write)) {
						using(StreamWriter writer = new StreamWriter(stream)) {
							writer.Write(generatedScript);
							writer.Close();
						}
						stream.Close();
					}
				} else {//For the scene object.
					path = EditorUtility.SaveFilePanel("Save Script", "Assets", fileName + ".cs", "cs");
					if(informations != null) {
						uNodeEditor.SavedData.RegisterGraphInfos(informations, script.graphOwner, path);
					}
					using(FileStream stream = File.Open(path, FileMode.Create, FileAccess.Write)) {
						using(StreamWriter writer = new StreamWriter(stream)) {
							writer.Write(generatedScript);
							writer.Close();
						}
						stream.Close();
					}
				}
				if(uNodePreference.preferenceData.IsAutoRefreshEnabled) {
					AssetDatabase.Refresh();
				}
				Debug.Log("Script saved to: " + Path.GetFullPath(path));
				EditorUtility.ClearProgressBar();
			}
			catch {
				EditorUtility.ClearProgressBar();
				Debug.LogError("Aborting Generating C# Script because have error.");
				throw;
			} finally {
				if(prefabContent != null) {
					PrefabUtility.UnloadPrefabContents(prefabContent);
				}
			}
		}

		public static bool LoadRuntimeAssembly() {
			var pdbPath = Path.ChangeExtension(tempAssemblyPath, ".pdb");
			if(File.Exists(tempAssemblyPath)) {
				var rawAssembly = File.ReadAllBytes(tempAssemblyPath);
				Assembly assembly;
				if(pdbPath != null) {
					var pdb = File.ReadAllBytes(pdbPath);
					assembly = Assembly.Load(rawAssembly, pdb);
				} else {
					assembly = Assembly.Load(rawAssembly);
				}
				if(assembly != null) {
					ReflectionUtils.RegisterRuntimeAssembly(assembly);
					ReflectionUtils.UpdateAssemblies();
					ReflectionUtils.GetAssemblies();
					return true;
				}
			}
			return false;
		}

		public static void CompileProjectGraphsAnonymous() {
			if(CanCompileScript()) {
				var scripts = GenerateProjectScripts(true);
				var dir = "TempScript" + Path.DirectorySeparatorChar + "GeneratedOnPlay";
				Directory.CreateDirectory(dir);
				HashSet<string> fileNames = new HashSet<string>();
				List<string> paths = new List<string>();
				foreach(var script in scripts) {
					var fileName = script.fileName;
					int index = 2;
					while(!fileNames.Add(fileName)) {
						fileName = script.fileName + index;
					}
					string path;
					if(string.IsNullOrWhiteSpace(script.Namespace) == false) {
						Directory.CreateDirectory(dir + Path.DirectorySeparatorChar + script.Namespace);
						path = Path.GetFullPath(dir) + Path.DirectorySeparatorChar + script.Namespace + Path.DirectorySeparatorChar + script.fileName + ".cs";
					}
					else {
						path = Path.GetFullPath(dir) + Path.DirectorySeparatorChar + script.fileName + ".cs";
					}
					using(StreamWriter sw = new StreamWriter(path)) {
						var generatedScript = script.ToScript(out var informations, true);
						if(informations != null) {
							uNodeEditor.SavedData.RegisterGraphInfos(informations, script.graphOwner, path);
						}
						sw.Write(ConvertLineEnding(generatedScript, false));
						sw.Close();
					}
					GraphUtility.UpdateDatabase(new[] { script });
					paths.Add(path);
				}
				ReflectionUtils.RegisterRuntimeAssembly(CompileFromFile(paths.ToArray()));
				ReflectionUtils.UpdateAssemblies();
				ReflectionUtils.GetAssemblies();
			}
		}

		internal static void CompileAndPatchProjectGraphs() {
			if(CanCompileScript() && EditorBinding.patchType != null) {
				var scripts = GenerateProjectScripts(true);
				var dir = "TempScript" + Path.DirectorySeparatorChar + "GeneratedOnPlay";
				Directory.CreateDirectory(dir);
				List<Type> types = new List<Type>();
				HashSet<string> fileNames = new HashSet<string>();
				List<string> paths = new List<string>();
				foreach(var script in scripts) {
					var fileName = script.fileName;
					int index = 2;
					while(!fileNames.Add(fileName)) {
						fileName = script.fileName + index;
					}
					string path;
					if(string.IsNullOrWhiteSpace(script.Namespace) == false) {
						Directory.CreateDirectory(dir + Path.DirectorySeparatorChar + script.Namespace);
						path = Path.GetFullPath(dir) + Path.DirectorySeparatorChar + script.Namespace + Path.DirectorySeparatorChar + script.fileName + ".cs";
					}
					else {
						path = Path.GetFullPath(dir) + Path.DirectorySeparatorChar + script.fileName + ".cs";
					}
					using(StreamWriter sw = new StreamWriter(path)) {
						var generatedScript = script.ToScript(out var informations, true);
						if(informations != null) {
							uNodeEditor.SavedData.RegisterGraphInfos(informations, script.graphOwner, path);
						}
						sw.Write(ConvertLineEnding(generatedScript, false));
						sw.Close();
					}
					GraphUtility.UpdateDatabase(new[] { script });
					paths.Add(path);
					var ns = script.Namespace;
					foreach(var pair in script.classNames) {
						if(string.IsNullOrEmpty(ns)) {
							types.Add(pair.Value.ToType(false));
						} else {
							types.Add((ns + "." + pair.Value).ToType(false));
						}
					}
				}
				var assembly = CompileFromFile(paths.ToArray());
				if(assembly == null)
					return;
				for(int i=0;i<types.Count;i++) {
					if(types[i] == null)
						continue;
					var type = assembly.GetType(types[i].FullName);
					if(type != null) {
						EditorUtility.DisplayProgressBar("Patching", "Patch generated c# into existing script.", (float)i / types.Count);
						EditorBinding.patchType(types[i], type);
					}
				}
				ReflectionUtils.RegisterRuntimeAssembly(assembly);
				ReflectionUtils.UpdateAssemblies();
				ReflectionUtils.GetAssemblies();
			}
		}

		public static CG.GeneratedData[] GenerateProjectScripts(
			bool force, 
			string label = "Generating C# Scripts", 
			bool clearProgressOnFinish = true) {
			try {
				var objects = GraphUtility.FindGraphs<GraphAsset>().ToArray();
				int count = 0;
				var scripts = objects.Select(g => {
					count++;
					if (g is GraphAsset graphAsset) {
						var graphSystem = GraphUtility.GetGraphSystem(graphAsset);
						if (!graphSystem.allowAutoCompile) {
							return null;
						}
						if(graphAsset is ITypeWithScriptData) {
							ITypeWithScriptData typeWithScriptData = graphAsset as ITypeWithScriptData;
							if(typeWithScriptData.ScriptData.compileToScript == false) {
								//Skip if compile to script is false
								var cachedData = persistenceData.GetGraphData(graphAsset);
								if(cachedData != null && cachedData.isValid) {
									cachedData.MarkDirty();
									if(File.Exists(tempAssemblyPath)) {
										File.Delete(tempAssemblyPath);
									}
								}
								return null;
							}
						}
						return GenerateCSharpScript(graphAsset, (progress, text) => {
							EditorUtility.DisplayProgressBar($"{label} {count}-{objects.Length}", text, progress);
						});
					} else {
						throw new InvalidOperationException(g.GetType().FullName);
					}
				}).Where(s => s != null);
				return scripts.ToArray();
			} finally {
				if (clearProgressOnFinish) {
					uNodeThreadUtility.QueueOnFrame(() => {
						EditorUtility.ClearProgressBar();
					});
				}
			}
		}

#region GenerateCSharpScript
		public static CG.GeneratedData GenerateCSharpScript(UnityEngine.Object source, Action<float, string> updateProgress = null, Action<CG.GeneratedData> onSuccess = null, Action<CG.GeneratedData> onInitialize = null) {
			if(source == null) {
				return null;
			}
			GeneratedScriptData scriptData;
			bool debug, debugValue;
			if (source is IScriptGraph scriptGraph) {
				scriptData = scriptGraph.ScriptData;
				debug = scriptData.debug;
				debugValue = scriptData.debugValueNode;
			} else if(source is ITypeWithScriptData typeWithScriptData) {
				scriptData = typeWithScriptData.ScriptData;
				debug = scriptData.debug;
				debugValue = scriptData.debugValueNode;
			} else {
				throw new Exception("Unsupported graph type: " + source.GetType());
			}
			return CG.Generate(new CG.GeneratorSetting(source) {
				fullTypeName = preferenceData.generatorData.fullTypeName,
				fullComment = preferenceData.generatorData.fullComment,
				generationMode = preferenceData.generatorData.generationMode,
				runtimeOptimization = preferenceData.generatorData.optimizeRuntimeCode && uNodeUtility.IsProVersion,
				debugScript = debug,
				debugValueNode = debugValue,
				updateProgress = updateProgress,
				onSuccess = onSuccess,
				onInitialize = onInitialize,
			});
		}

		public static CG.GeneratedData GenerateCSharpScriptForIdentifier(UnityEngine.Object source, Action<float, string> updateProgress = null, Action<CG.GeneratedData> onSuccess = null, Action<CG.GeneratedData> onInitialize = null) {
			if(source == null) {
				return null;
			}
			GeneratedScriptData scriptData;
			bool debug, debugValue;
			if(source is IScriptGraph scriptGraph) {
				scriptData = scriptGraph.ScriptData;
				debug = scriptData.debug;
				debugValue = scriptData.debugValueNode;
			}
			else if(source is ITypeWithScriptData typeWithScriptData) {
				scriptData = typeWithScriptData.ScriptData;
				debug = scriptData.debug;
				debugValue = scriptData.debugValueNode;
			}
			else {
				throw new Exception("Unsupported graph type: " + source.GetType());
			}
			return CG.Generate(new CG.GeneratorSetting(source) {
				fullTypeName = preferenceData.generatorData.fullTypeName,
				fullComment = false,
				generationMode = GenerationKind.Compatibility,
				runtimeOptimization = false,
				debugScript = debug,
				debugValueNode = debugValue,
				updateProgress = updateProgress,
				onSuccess = onSuccess,
				onInitialize = onInitialize,
				generateIdentifierOnly = true,
			});
		}
		#endregion

		#region GenerateCSharpAsync
		/// <summary>
		/// Generate Project Script in background.
		/// Note: don't call it from main thread.
		/// </summary>
		/// <param name="force"></param>
		/// <param name="label"></param>
		/// <param name="clearProgressOnFinish"></param>
		/// <returns></returns>
		public static CG.GeneratedData[] GenerateRuntimeGraphAsync(
			bool force,
			string label = "Generating C# Scripts",
			bool clearProgressOnFinish = true) {
			try {
				List<UnityEngine.Object> objects = new List<UnityEngine.Object>();
				uNodeThreadUtility.QueueAndWait(() => {
					//Find graphs in main thread.
					objects.AddRange(GraphUtility.FindGraphs<GraphAsset>());
				});
				int count = 0;
				List<CG.GeneratedData> scripts = new List<CG.GeneratedData>();
				foreach(var g in objects) {
					count++;
					if(g is GraphAsset graphAsset) {
						uNodeThreadUtility.QueueAndWait(() => {
							if(graphAsset is ITypeWithScriptData) {
								ITypeWithScriptData typeWithScriptData = graphAsset as ITypeWithScriptData;
								if(typeWithScriptData.ScriptData.compileToScript == false) {
									//Skip if compile to script is false
									var cachedData = persistenceData.GetGraphData(graphAsset);
									if(cachedData != null && cachedData.isValid) {
										cachedData.MarkDirty();
										if(File.Exists(tempAssemblyPath)) {
											File.Delete(tempAssemblyPath);
										}
									}
									graphAsset = null;
									return;
								}
							}
							if(!force /*&& !GraphUtility.HasTempGraphObject(gameObject)*/ && IsGraphUpToDate(graphAsset)) {
								var settings = new CG.GeneratorSetting(graphAsset as Object) {
									fullTypeName = true /*preferenceData.generatorData.fullTypeName*/,
									fullComment = false /*preferenceData.generatorData.fullComment*/,
									generationMode = preferenceData.generatorData.generationMode,
									runtimeOptimization = preferenceData.generatorData.optimizeRuntimeCode && uNodeUtility.IsProVersion,
									//debugScript = debug,
									//debugValueNode = debugValue,
								};
								var script = new CG.GeneratedData(settings);
								script.InitOwner();
								scripts.Add(script);
								graphAsset = null;
							};
						});
						if(graphAsset == null || !GraphUtility.GetGraphSystem(graphAsset).allowAutoCompile) {
							continue;
						}
						scripts.Add(GenerateCSharpAsync(graphAsset, (progress, text) => {
							EditorProgressBar.ShowProgressBar($"{label} {count}-{objects.Count}", (float)count / (float)objects.Count);
						}));
					} 
					//TODO: fix me
					//else if(g is uNodeInterface iface) {
					//	EditorProgressBar.ShowProgressBar($"Generating interface {iface.name} {count}-{objects.Count}", (float)count / (float)objects.Count);
					//	uNodeThreadUtility.QueueAndWait(() => {
					//		scripts.Add(GenerateCSharpScript(iface));
					//	});
					//} 
					else {
						throw new InvalidOperationException(g.GetType().FullName);
					}
				}
				return scripts.ToArray();
			}
			finally {
				if(clearProgressOnFinish) {
					EditorProgressBar.ClearProgressBar();
				}
			}
		}

		/// <summary>
		/// Generate CSharp Script Async.
		/// Note: Don't call in main thread.
		/// </summary>
		/// <param name="source"></param>
		/// <param name="updateProgress"></param>
		/// <returns></returns>
		public static CG.GeneratedData GenerateCSharpAsync(Object source, Action<float, string> updateProgress = null) {
			if(source == null) {
				return null;
			}
			GeneratedScriptData scriptData;
			bool debug, debugValue;
			if (source is IScriptGraph scriptGraph) {
				scriptData = scriptGraph.ScriptData;
				debug = scriptData.debug;
				debugValue = scriptData.debugValueNode;
			}
			else if (source is ITypeWithScriptData typeWithScriptData) {
				scriptData = typeWithScriptData.ScriptData;
				debug = scriptData.debug;
				debugValue = scriptData.debugValueNode;
			}
			else {
				throw new Exception("Unsupported graph type: " + source.GetType());
			}
			return CG.Generate(new CG.GeneratorSetting(source) {
				fullTypeName = true /*preferenceData.generatorData.fullTypeName*/,
				fullComment = false /*preferenceData.generatorData.fullComment*/,
				generationMode = preferenceData.generatorData.generationMode,
				runtimeOptimization = preferenceData.generatorData.optimizeRuntimeCode && uNodeUtility.IsProVersion,
				debugScript = debug,
				debugValueNode = debugValue,
				updateProgress = updateProgress,
				isAsync = true,
			});
		}
#endregion

		public static string ConvertLineEnding(string text, bool isUnixFormat) {
			var regex = new System.Text.RegularExpressions.Regex(@"(?<!\r)\n");
			const string LineEnd = "\r\n";

			string originalText = text;
			string changedText;
			changedText = regex.Replace(originalText, LineEnd);
			if(isUnixFormat) {
				changedText = changedText.Replace(LineEnd, "\n");
			}
			return changedText;
		}

#region Compile
		public static CompileResult CompileScript(params string[] source) {
			return RoslynUtility.CompileScript(source);
		}

		public static bool CanCompileScript() {
			return true;
		}

		public static Assembly Compile(params string[] source) {
			var compileResult = RoslynUtility.CompileScript(source);

			if(compileResult.isSuccess == false) {
				//compileResult.LogErrors();
				throw new Exception(compileResult.GetErrorMessage());
			}
			return compileResult.LoadAssembly();
		}

		public static Assembly CompileFromFile(params string[] files) {
			var compileResult = RoslynUtility.CompileFiles(files);

			if(compileResult.isSuccess == false) {
				//compileResult.LogErrors();
				throw new Exception(compileResult.GetErrorMessage());
			}
			return compileResult.LoadAssembly();
		}
#endregion
	}
}